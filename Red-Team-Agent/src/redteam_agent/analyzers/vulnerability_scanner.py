"""Vulnerability scanner — static analysis for OWASP Top 10 and common security flaws."""

from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path

SKIP_DIRS = {
    "node_modules", ".git", "__pycache__", ".mypy_cache", "venv", ".venv",
    "env", ".env", "dist", "build", ".tox", "vendor", "target",
    ".pytest_cache", ".ruff_cache",
}

SCAN_EXTS = {".py", ".js", ".ts", ".jsx", ".tsx", ".go", ".rb", ".java", ".php"}


@dataclass
class VulnFinding:
    """A single vulnerability finding."""
    category: str        # e.g., "sql_injection", "xss", "command_injection"
    severity: str        # "critical", "high", "medium", "low", "info"
    file: str
    line: int
    code: str            # the offending line
    description: str
    remediation: str
    cwe: str | None      # CWE identifier if applicable
    owasp: str | None    # OWASP category if applicable

    def to_dict(self) -> dict:
        return {
            "category": self.category,
            "severity": self.severity,
            "file": self.file,
            "line": self.line,
            "code": self.code.strip(),
            "description": self.description,
            "remediation": self.remediation,
            "cwe": self.cwe,
            "owasp": self.owasp,
        }


# -- Vulnerability patterns by language --

PYTHON_PATTERNS: list[dict] = [
    # SQL Injection
    {
        "pattern": re.compile(r"""(?:execute|cursor\.execute|\.raw)\s*\(\s*(?:f['""]|['""].*%s|.*\.format\()"""),
        "category": "sql_injection",
        "severity": "critical",
        "description": "SQL query constructed with string formatting — vulnerable to SQL injection.",
        "remediation": "Use parameterized queries: cursor.execute('SELECT * FROM t WHERE id = %s', (user_id,))",
        "cwe": "CWE-89",
        "owasp": "A03:2021 Injection",
    },
    # Command Injection
    {
        "pattern": re.compile(r"""(?:os\.system|os\.popen|subprocess\.(?:call|run|Popen))\s*\(.*(?:f['""]|\.format\(|%\s)"""),
        "category": "command_injection",
        "severity": "critical",
        "description": "OS command constructed with user-controlled input — command injection risk.",
        "remediation": "Use subprocess with a list of args (no shell=True) and validate all inputs.",
        "cwe": "CWE-78",
        "owasp": "A03:2021 Injection",
    },
    {
        "pattern": re.compile(r"""subprocess\..*shell\s*=\s*True"""),
        "category": "command_injection",
        "severity": "high",
        "description": "subprocess called with shell=True — enables shell injection.",
        "remediation": "Use shell=False (default) and pass args as a list.",
        "cwe": "CWE-78",
        "owasp": "A03:2021 Injection",
    },
    # Insecure Deserialization
    {
        "pattern": re.compile(r"""(?:pickle\.loads?|yaml\.(?:load|unsafe_load))\s*\("""),
        "category": "insecure_deserialization",
        "severity": "critical",
        "description": "Deserializing untrusted data — can lead to remote code execution.",
        "remediation": "Use yaml.safe_load() or json instead of pickle for untrusted data.",
        "cwe": "CWE-502",
        "owasp": "A08:2021 Software and Data Integrity Failures",
    },
    # Eval / Exec
    {
        "pattern": re.compile(r"""(?:eval|exec)\s*\("""),
        "category": "code_injection",
        "severity": "critical",
        "description": "eval()/exec() can execute arbitrary code if input is user-controlled.",
        "remediation": "Remove eval/exec. Use ast.literal_eval() for safe parsing of literals.",
        "cwe": "CWE-95",
        "owasp": "A03:2021 Injection",
    },
    # Path Traversal
    {
        "pattern": re.compile(r"""open\s*\(.*(?:f['""]|\.format\(|%\s|\+\s*(?:request|user|input))"""),
        "category": "path_traversal",
        "severity": "high",
        "description": "File path constructed from user input — path traversal risk.",
        "remediation": "Validate/sanitize file paths. Use os.path.realpath() and check against allowed directory.",
        "cwe": "CWE-22",
        "owasp": "A01:2021 Broken Access Control",
    },
    # Hardcoded Secrets
    {
        "pattern": re.compile(r"""(?:password|secret|api_key|token|aws_secret)\s*=\s*['""][^'""]{8,}['""]""", re.IGNORECASE),
        "category": "hardcoded_secret",
        "severity": "high",
        "description": "Hardcoded secret/credential in source code.",
        "remediation": "Use environment variables or a secrets manager (e.g., AWS Secrets Manager, HashiCorp Vault).",
        "cwe": "CWE-798",
        "owasp": "A07:2021 Identification and Authentication Failures",
    },
    # Weak Crypto
    {
        "pattern": re.compile(r"""(?:hashlib\.md5|hashlib\.sha1|MD5|SHA1)\s*\("""),
        "category": "weak_crypto",
        "severity": "medium",
        "description": "Weak hash algorithm (MD5/SHA1) — not suitable for passwords or security.",
        "remediation": "Use bcrypt, scrypt, or argon2 for passwords. SHA-256+ for integrity checks.",
        "cwe": "CWE-328",
        "owasp": "A02:2021 Cryptographic Failures",
    },
    # Debug Mode
    {
        "pattern": re.compile(r"""(?:DEBUG\s*=\s*True|app\.run\(.*debug\s*=\s*True)"""),
        "category": "debug_mode",
        "severity": "medium",
        "description": "Debug mode enabled — exposes stack traces and internal state.",
        "remediation": "Set DEBUG=False in production. Use environment-based configuration.",
        "cwe": "CWE-215",
        "owasp": "A05:2021 Security Misconfiguration",
    },
    # SSRF
    {
        "pattern": re.compile(r"""(?:requests\.get|httpx\.get|urllib\.request\.urlopen)\s*\(.*(?:f['""]|\.format|request\.)"""),
        "category": "ssrf",
        "severity": "high",
        "description": "HTTP request with user-controlled URL — Server-Side Request Forgery risk.",
        "remediation": "Validate URLs against an allowlist. Block internal/private IP ranges.",
        "cwe": "CWE-918",
        "owasp": "A10:2021 Server-Side Request Forgery",
    },
    # Missing CSRF Protection
    {
        "pattern": re.compile(r"""@app\.route\(.*methods\s*=\s*\[.*(?:POST|PUT|DELETE)"""),
        "category": "csrf",
        "severity": "medium",
        "description": "State-changing endpoint — ensure CSRF protection is enabled.",
        "remediation": "Use CSRF tokens (Flask-WTF, Django middleware) for all state-changing requests.",
        "cwe": "CWE-352",
        "owasp": "A01:2021 Broken Access Control",
    },
    # Insecure Random
    {
        "pattern": re.compile(r"""random\.(?:random|randint|choice|randrange)\s*\("""),
        "category": "insecure_random",
        "severity": "low",
        "description": "Using random module for potentially security-sensitive operation.",
        "remediation": "Use secrets module for tokens, passwords, and security-critical random values.",
        "cwe": "CWE-330",
        "owasp": "A02:2021 Cryptographic Failures",
    },
]

JS_PATTERNS: list[dict] = [
    # XSS
    {
        "pattern": re.compile(r"""(?:innerHTML|outerHTML|document\.write)\s*="""),
        "category": "xss",
        "severity": "high",
        "description": "Direct DOM manipulation with innerHTML — XSS vulnerability.",
        "remediation": "Use textContent or a framework's built-in escaping (React JSX, DOMPurify).",
        "cwe": "CWE-79",
        "owasp": "A03:2021 Injection",
    },
    {
        "pattern": re.compile(r"""(?:dangerouslySetInnerHTML)"""),
        "category": "xss",
        "severity": "high",
        "description": "dangerouslySetInnerHTML used — XSS risk if content is not sanitized.",
        "remediation": "Sanitize HTML with DOMPurify before rendering. Prefer safe alternatives.",
        "cwe": "CWE-79",
        "owasp": "A03:2021 Injection",
    },
    # SQL Injection (template strings)
    {
        "pattern": re.compile(r"""(?:query|execute)\s*\(\s*`[^`]*\$\{"""),
        "category": "sql_injection",
        "severity": "critical",
        "description": "SQL query built with template literals — SQL injection risk.",
        "remediation": "Use parameterized queries or prepared statements.",
        "cwe": "CWE-89",
        "owasp": "A03:2021 Injection",
    },
    # Command Injection
    {
        "pattern": re.compile(r"""(?:child_process\.exec|execSync)\s*\(\s*(?:`|\$|.*\+)"""),
        "category": "command_injection",
        "severity": "critical",
        "description": "Command execution with dynamic input — command injection risk.",
        "remediation": "Use child_process.execFile() with args array instead of exec().",
        "cwe": "CWE-78",
        "owasp": "A03:2021 Injection",
    },
    # Eval
    {
        "pattern": re.compile(r"""(?:eval|Function)\s*\("""),
        "category": "code_injection",
        "severity": "critical",
        "description": "eval()/new Function() can execute arbitrary code.",
        "remediation": "Remove eval(). Use JSON.parse() for data, proper parsers for expressions.",
        "cwe": "CWE-95",
        "owasp": "A03:2021 Injection",
    },
    # Hardcoded Secrets
    {
        "pattern": re.compile(r"""(?:apiKey|secret|password|token)\s*[:=]\s*['""][^'""]{8,}['""]""", re.IGNORECASE),
        "category": "hardcoded_secret",
        "severity": "high",
        "description": "Hardcoded secret in JavaScript source — accessible to anyone.",
        "remediation": "Use environment variables (process.env) or a secrets manager.",
        "cwe": "CWE-798",
        "owasp": "A07:2021 Identification and Authentication Failures",
    },
    # Prototype Pollution
    {
        "pattern": re.compile(r"""(?:__proto__|constructor\.prototype)"""),
        "category": "prototype_pollution",
        "severity": "high",
        "description": "Prototype pollution vector — can modify object behavior globally.",
        "remediation": "Use Object.create(null) for lookup objects. Validate input keys.",
        "cwe": "CWE-1321",
        "owasp": "A03:2021 Injection",
    },
]

GO_PATTERNS: list[dict] = [
    # SQL Injection
    {
        "pattern": re.compile(r"""(?:fmt\.Sprintf|string\s*\+).*(?:Query|Exec)\s*\("""),
        "category": "sql_injection",
        "severity": "critical",
        "description": "SQL query built with string formatting — SQL injection risk.",
        "remediation": "Use parameterized queries: db.Query('SELECT * FROM t WHERE id = $1', id)",
        "cwe": "CWE-89",
        "owasp": "A03:2021 Injection",
    },
    # Command Injection
    {
        "pattern": re.compile(r"""exec\.Command\s*\(\s*(?:"sh"|"bash"|"/bin/sh")"""),
        "category": "command_injection",
        "severity": "high",
        "description": "Shell command execution — validate inputs carefully.",
        "remediation": "Avoid shell execution. Use exec.Command with explicit args, no shell.",
        "cwe": "CWE-78",
        "owasp": "A03:2021 Injection",
    },
]


def scan_vulnerabilities(root: str) -> list[VulnFinding]:
    """Scan a codebase for security vulnerabilities."""
    root_path = Path(root).resolve()
    findings: list[VulnFinding] = []

    for file_path in root_path.rglob("*"):
        if any(skip in file_path.parts for skip in SKIP_DIRS):
            continue
        if not file_path.is_file():
            continue
        if file_path.suffix not in SCAN_EXTS:
            continue

        try:
            content = file_path.read_text(errors="replace")
        except OSError:
            continue

        rel = str(file_path.relative_to(root_path))
        lines = content.split("\n")

        # Select patterns based on file extension
        if file_path.suffix == ".py":
            patterns = PYTHON_PATTERNS
        elif file_path.suffix in (".js", ".ts", ".jsx", ".tsx"):
            patterns = JS_PATTERNS
        elif file_path.suffix == ".go":
            patterns = GO_PATTERNS
        else:
            patterns = PYTHON_PATTERNS + JS_PATTERNS  # broad scan

        for line_num, line in enumerate(lines, 1):
            for pat in patterns:
                if pat["pattern"].search(line):
                    findings.append(VulnFinding(
                        category=pat["category"],
                        severity=pat["severity"],
                        file=rel,
                        line=line_num,
                        code=line,
                        description=pat["description"],
                        remediation=pat["remediation"],
                        cwe=pat.get("cwe"),
                        owasp=pat.get("owasp"),
                    ))

    # Check for sensitive files
    sensitive_files = [
        (".env", "high", "Environment file may contain secrets."),
        ("id_rsa", "critical", "Private SSH key in repository."),
        ("id_ed25519", "critical", "Private SSH key in repository."),
        (".pem", "critical", "Private key/certificate in repository."),
        ("credentials.json", "critical", "Credentials file in repository."),
        ("service-account.json", "critical", "GCP service account key in repository."),
        (".htpasswd", "high", "HTTP password file in repository."),
        ("wp-config.php", "high", "WordPress config with DB credentials."),
    ]
    for name, severity, desc in sensitive_files:
        for found in root_path.rglob(f"*{name}"):
            if any(skip in found.parts for skip in SKIP_DIRS):
                continue
            if ".git" in found.parts:
                continue
            findings.append(VulnFinding(
                category="sensitive_file",
                severity=severity,
                file=str(found.relative_to(root_path)),
                line=0,
                code=f"File: {found.name}",
                description=desc,
                remediation="Remove from repo, add to .gitignore, rotate exposed credentials.",
                cwe="CWE-200",
                owasp="A01:2021 Broken Access Control",
            ))

    # Check .gitignore coverage
    gitignore_path = root_path / ".gitignore"
    if gitignore_path.exists():
        gitignore = gitignore_path.read_text(errors="replace")
        critical_ignores = [".env", "*.pem", "*.key", "id_rsa", "credentials.json"]
        missing = [p for p in critical_ignores if p not in gitignore]
        if missing:
            findings.append(VulnFinding(
                category="gitignore_gap",
                severity="medium",
                file=".gitignore",
                line=0,
                code=f"Missing: {', '.join(missing)}",
                description=f".gitignore is missing entries for sensitive patterns: {', '.join(missing)}",
                remediation=f"Add these patterns to .gitignore: {', '.join(missing)}",
                cwe="CWE-200",
                owasp="A05:2021 Security Misconfiguration",
            ))
    else:
        findings.append(VulnFinding(
            category="gitignore_gap",
            severity="medium",
            file="(missing)",
            line=0,
            code="No .gitignore file",
            description="No .gitignore file — secrets and build artifacts may be committed.",
            remediation="Create a .gitignore with entries for .env, *.pem, *.key, node_modules, etc.",
            cwe="CWE-200",
            owasp="A05:2021 Security Misconfiguration",
        ))

    # Sort by severity
    severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
    findings.sort(key=lambda f: severity_order.get(f.severity, 5))

    return findings
